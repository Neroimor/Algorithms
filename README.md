# Алгоритмы

## Алгоритмы сортировки

### Сортировка пузырьком (Bubble sorting)

Концепция: В алгоритме сортировки пузырьком элемент как-бы всплывает на поверхность.

Шаги:
1) проходимся по всем элементам массива
2) сравниваем два соседних элемента массива
3) если текущий элемент больше следующего то меняем их местами

![BubbleSort](https://github.com/user-attachments/assets/b69bbc0e-a1a0-4423-ad72-c39896c630d5)


### Сортировка выбором (Sorting by selection)

В сортировки выбором у нас происходят:
1) Поиск индекса минимального элемента
2) Меняем текущий элемент с минимальным местами


![Selection](https://github.com/user-attachments/assets/e8bfe643-193c-4175-ad0c-eda6037548ef)


### Сортировка вставками (Sorting by insertion)

В сортировке вставками начинаем со второго элемента. Проверяем между собой второй элемент с первым и, если надо, меняем местами. Сравниваем следующую пару элементов и проверяем все пары до нее.

1) Начинаем с второго элемента, так как один элемент уже считается отсортированным. 
2) Берём текущий элемент и сравниваем с предыдущими, пока не найдём место, куда его вставить.
3) Смещаем все элементы, которые больше текущего, вправо и вставляем элемент на его место.
4) Повторяем процесс для всех элементов.

![Insert](https://github.com/user-attachments/assets/5fbab5ee-1094-4080-b30e-129b007e66be)

### Быстрая сортировка (Quick sorting)
В основе быстрой сортировки лежит стратегия «разделяй и властвуй». Задача разделяется на более мелкие подзадачи. Подзадачи решаются отдельно, а потом решения объединяют. Точно так же, массив разделяется на подмассивы, которые сортируются и затем сливаются в один.

1) В первую очередь выбираем опорный элемент. Все значения больше опорного элемента ставятся после него, остальные — перед.
2) Опорным может быть любой элемент. Мы выбираем последний в списке.
3) Чтобы расположить элементы большие — справа от опорного элемента, а меньшие — слева, будем двигаться от начала списка. Если число будет больше опорного, то оно ставится на его место, а сам опорный на место перед ним.

![Quick](https://github.com/user-attachments/assets/6d1d9623-28bb-450b-a14e-d4c14c6ed7f2)




## Алгоритмы умножения


### Алгоритм Карацуба (Karatsuba algorithm)

Алгоритм Карацуба — это метод умножения больших чисел, который использует разбиение чисел на части и рекурсивное вычисление произведения. Он эффективнее традиционного умножения, особенно для очень больших чисел.

X = 5678, Y = 1234
Шаги: 
1) Разделить X и Y на две равные части (n = 4 цифры → половина = 2 цифры):
   X = 5678  →  a = 56, b = 78
   Y = 1234  →  c = 12, d = 34

2) Произведения половин:
   ac = 56 × 12 = 672
   bd = 78 × 34 = 2652

3) Произведение сумм:
   (a + b) = 56 + 78 = 134
   (c + d) = 12 + 34 = 46
   (a + b) × (c + d) = 134 × 46 = 6164

4) «Средний» член:
   ad+bc = 6164 − 672 − 2652 = 2840

5) Сборка результата (так как n = 4, то 10ⁿ = 10⁴, n/2 = 2 → 10^(n/2) = 10²):
   X × Y = ac·10⁴ + (ad+bc)·10² + bd  
         = 672·10⁴ + 2840·10² + 2652  
         = 6 720 000 + 284 000 + 2 652  
         = 7 006 652

ИТОГО: 5678 × 1234 = 7006652

Код программы на C#:
```csharp
        private int KaratsubaCross(int x, int y)
        {
            if (x < 10 || y < 10)
                return x * y;

            int n1 = x.ToString().Length, n2 = y.ToString().Length;
            int n = Math.Max(n1, n2);
            if (n % 2 != 0) n++;
            int half = n / 2;


            string value1 = x.ToString().PadLeft(n, '0');
            string value2 = y.ToString().PadLeft(n, '0');
            string tempA = value1.Substring(0, half);
            string tempB = value1.Substring(half);
            string tempC = value2.Substring(0, half);
            string tempD = value2.Substring(half);
    


            int a = int.Parse(tempA);
            int b = int.Parse(tempB);
            int c = int.Parse(tempC);
            int d = int.Parse(tempD);
            int p = a + b;
            int q = c+d;
            int pq = KaratsubaCross(p, q);
            int ac = KaratsubaCross(a, c);
            int bd = KaratsubaCross(b, d);
            int adbc = pq-ac-bd;




            return (int)Math.Pow(10,n)*ac+(int)Math.Pow(10,n/2)*adbc+bd;
        }
```

### Алгоритм начальной школы (умножение столбиком)

Эффект Черепахи и Зайца, или как умножать числа столбиком

1. **Преобразование входных данных**  
   - Получаем два множителя `a` и `b` в виде строк.  
   - Превращаем их в массивы символов `oneMultiplier` и `twoMultiplier`.  
   - Создаём массив `arrIntermediate` длины `b.Length` для хранения частичных произведений.

2. **Вычисление частичных произведений**  
   - Проходим по каждой цифре второго множителя (`twoMultiplier[i]`) справа налево.  
   - Для каждой цифры заводим перенос `temp = 0` и создаём `StringBuilder`.  
   - Внутренним циклом пробегаем по цифрам первого множителя (`oneMultiplier[j]`) справа налево:  
      `cros = (digitA * digitB) + temp`.  
      Если `cros` двузначное — старшую цифру сохраняем в `temp`, младшую — в текущую позицию; иначе `temp = 0`.  
      Добавляем младшую цифру в `StringBuilder`.  
   - После обработки всех `j` разворачиваем накопленный `StringBuilder`, получаем строку частичного произведения и записываем её в `arrIntermediate[i]`.

3. **Выравнивание и построение матрицы**  
   - Разворачиваем `arrIntermediate`, чтобы самая «младшая» строка оказалась внизу.  
   - Для i‑го частичного произведения добавляем i пробелов справа (имитация смещения).  
   - Находим максимальную длину среди всех строк и создаём матрицу `char[,] matrix` размером `max × max`.  
   - Копируем каждую строку из `arrIntermediate` в соответствующую строку `matrix`, выравнивая цифры вправо (сдвиг `delta = max – length`).

4. **Печать матрицы (отладка)**  
   - Проходим по `matrix` и выводим каждый элемент с табуляцией, чтобы визуально проверить выравнивание.

5. **Суммирование столбиков**  
   - В методе `SumColumns` для каждого столбика `j` справа налево:  
      Складываем все цифры `matrix[i,j]` (игнорируем не‑цифры) и текущий перенос `carry`.  
      `digit = sum % 10` → добавляем в результат; `carry = sum / 10`.

6. **Формирование конечного результата**  
   - После последнего столбика, пока `carry > 0`, разбиваем его на цифры и дописываем в результат.  
   - Разворачиваем список полученных цифр и объединяем в одну строку — это и есть `a × b`.

```
      5678
    × 1234
    -------
      22712   ← 5678 × 4
     17034    ← 5678 × 3 (сдвиг 1)
    11356     ← 5678 × 2 (сдвиг 2)
   5678       ← 5678 × 1 (сдвиг 3)
    -------
    7006652
```


## Алгоритмы поиска

### Линейный поиск (Linear search)
Линейный поиск — это простой алгоритм, который проходит по всем элементам массива и сравнивает каждый элемент с искомым значением. Если значение найдено, возвращается его индекс, иначе возвращается -1.

```csharp
        private bool IsEqual(T a, T b)
        {
            return a.CompareTo(b) == 0;
        }

        public int Search(T[] array, T value)
        {

            for (int i = 0; i < array.Length; i++) {

                if (IsEqual(value, array[i]))
                {
                    return i;
                }
            }
            return -1;
        }
```


### Бинарный поиск (Binary search)

Бинарный поиск — это алгоритм, который работает на отсортированных массивах. Он делит массив пополам и сравнивает средний элемент с искомым значением. Если значение меньше среднего, поиск продолжается в левой половине, если больше — в правой.
Бинарный поиск можно решить рекурсивно или итеративно.


#### Рексурсивный способ
```csharp
        private int RecursionBinSearch(T[] array, T Value, int first, int last)
        {
            if (first > last)
            {
                return -1;
            }

            var middle = (first + last) / 2;
            var middleValue = array[middle];

            if (IsEqual(Value, middleValue))
            {
                return middle;
            }
            else
            {
                if (IsGreaterThan(Value, middleValue))
                {
                   return RecursionBinSearch(array, Value, middle + 1, last);
                }
                else
                {
                   return RecursionBinSearch(array, Value, first, middle - 1);
                }
            }


        }
```


#### Итеративный способ
```csharp
        private int IterativeBinSearch(T[] array, T value, int left, int right)
        {

            while (left <= right)
            {
                var middle = (left + right) / 2;

                if (IsEqual(value, array[middle]))
                {
                    return middle;
                }
                else if (IsLessThan(value, array[middle]))
                {
                    right = middle - 1;
                }
                else if (IsGreaterThan(value, array[middle]))
                {
                    left = middle + 1;
                }
            }

            return -1;
        }
```


## Алгоритмы возведения в степень

### Стандтный алгоритм возведения в степень (Standard exponentiation algorithm)

```
csharp
        private T Process(T a, int n)
        {
            T value = a;
            for (int i = 0; i < n-1; i++)
            {
                value*= a;
            }

            return value;
        }
```


## Как скачать

git clone https://github.com/Neroimor/Algorithms.git


