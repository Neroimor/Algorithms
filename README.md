# Алгоритмы

## Алгоритмы сортировки

### Сортировка пузырьком (Bubble sorting)

Концепция: В алгоритме сортировки пузырьком элемент как-бы всплывает на поверхность.

Шаги:
1) проходимся по всем элементам массива
2) сравниваем два соседних элемента массива
3) если текущий элемент больше следующего то меняем их местами

![BubbleSort](https://github.com/user-attachments/assets/b69bbc0e-a1a0-4423-ad72-c39896c630d5)


### Сортировка выбором (Sorting by selection)

В сортировки выбором у нас происходят:
1) Поиск индекса минимального элемента
2) Меняем текущий элемент с минимальным местами


![Selection](https://github.com/user-attachments/assets/e8bfe643-193c-4175-ad0c-eda6037548ef)


### Сортировка вставками (Sorting by insertion)

В сортировке вставками начинаем со второго элемента. Проверяем между собой второй элемент с первым и, если надо, меняем местами. Сравниваем следующую пару элементов и проверяем все пары до нее.

1) Начинаем с второго элемента, так как один элемент уже считается отсортированным. 
2) Берём текущий элемент и сравниваем с предыдущими, пока не найдём место, куда его вставить.
3) Смещаем все элементы, которые больше текущего, вправо и вставляем элемент на его место.
4) Повторяем процесс для всех элементов.

![Insert](https://github.com/user-attachments/assets/5fbab5ee-1094-4080-b30e-129b007e66be)

### Быстрая сортировка (Quick sorting)
В основе быстрой сортировки лежит стратегия «разделяй и властвуй». Задача разделяется на более мелкие подзадачи. Подзадачи решаются отдельно, а потом решения объединяют. Точно так же, массив разделяется на подмассивы, которые сортируются и затем сливаются в один.

1) В первую очередь выбираем опорный элемент. Все значения больше опорного элемента ставятся после него, остальные — перед.
2) Опорным может быть любой элемент. Мы выбираем последний в списке.
3) Чтобы расположить элементы большие — справа от опорного элемента, а меньшие — слева, будем двигаться от начала списка. Если число будет больше опорного, то оно ставится на его место, а сам опорный на место перед ним.

![Quick](https://github.com/user-attachments/assets/6d1d9623-28bb-450b-a14e-d4c14c6ed7f2)




## Алгоритмы умножения

### Алгоритм начальной школы (умножение столбиком)

Эффект Черепахи и Зайца, или как умножать числа столбиком

1. **Преобразование входных данных**  
   - Получаем два множителя `a` и `b` в виде строк.  
   - Превращаем их в массивы символов `oneMultiplier` и `twoMultiplier`.  
   - Создаём массив `arrIntermediate` длины `b.Length` для хранения частичных произведений.

2. **Вычисление частичных произведений**  
   - Проходим по каждой цифре второго множителя (`twoMultiplier[i]`) справа налево.  
   - Для каждой цифры заводим перенос `temp = 0` и создаём `StringBuilder`.  
   - Внутренним циклом пробегаем по цифрам первого множителя (`oneMultiplier[j]`) справа налево:  
      `cros = (digitA * digitB) + temp`.  
      Если `cros` двузначное — старшую цифру сохраняем в `temp`, младшую — в текущую позицию; иначе `temp = 0`.  
      Добавляем младшую цифру в `StringBuilder`.  
   - После обработки всех `j` разворачиваем накопленный `StringBuilder`, получаем строку частичного произведения и записываем её в `arrIntermediate[i]`.

3. **Выравнивание и построение матрицы**  
   - Разворачиваем `arrIntermediate`, чтобы самая «младшая» строка оказалась внизу.  
   - Для i‑го частичного произведения добавляем i пробелов справа (имитация смещения).  
   - Находим максимальную длину среди всех строк и создаём матрицу `char[,] matrix` размером `max × max`.  
   - Копируем каждую строку из `arrIntermediate` в соответствующую строку `matrix`, выравнивая цифры вправо (сдвиг `delta = max – length`).

4. **Печать матрицы (отладка)**  
   - Проходим по `matrix` и выводим каждый элемент с табуляцией, чтобы визуально проверить выравнивание.

5. **Суммирование столбиков**  
   - В методе `SumColumns` для каждого столбика `j` справа налево:  
      Складываем все цифры `matrix[i,j]` (игнорируем не‑цифры) и текущий перенос `carry`.  
      `digit = sum % 10` → добавляем в результат; `carry = sum / 10`.

6. **Формирование конечного результата**  
   - После последнего столбика, пока `carry > 0`, разбиваем его на цифры и дописываем в результат.  
   - Разворачиваем список полученных цифр и объединяем в одну строку — это и есть `a × b`.

```
      5678
    × 1234
    -------
      22712   ← 5678 × 4
     17034    ← 5678 × 3 (сдвиг 1)
    11356     ← 5678 × 2 (сдвиг 2)
   5678       ← 5678 × 1 (сдвиг 3)
    -------
    7006652
```


## Как скачать

git clone https://github.com/Neroimor/Algorithms.git
